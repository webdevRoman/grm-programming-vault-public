---
tags:
  - interview
  - java
  - programming
---
Источники:
https://struchkov.dev/blog/ru/modifiers-in-java/

### Модификаторы доступа

Позволяют указать разрешённую область видимости для членов класса.

---

##### private

Не позволяет использовать члены класса за пределами класса.

Если создать приватный конструктор, то создать объект такого класса не выйдет. При условии, что у класса не будет других конструкторов. Также не получится сделать наследника, так как при наследовании вызывается конструктор класса родителя.

Приватный конструктор может понадобиться:
1. Статические фабричные методы для создания объекта. Таким образом, мы скрываем конструктор и оставляем только фабричные методы.
2. Создание утилитарных классов. Чтобы запретить создавать объекты таких классов, так как это не имеет никакого смысла.

---

##### default-package

Доступ внутри этого класса, а также у всех классов, которые находятся в этом пакете.

Особенность — отсутствие ключевого слова. Если не указывать модификатор, `default-package` применяется по умолчанию.

---

##### protected

Обладает свойствами модификаторов `private` и `default-package`, а также позволяет наследникам обращаться к членам класса родителя.

---

##### public

Позволяет обращаться к членам класса откуда угодно.

---

##### Шпаргалка

![[java_access_modifiers.png|700]]

---

### Прочие модификаторы

##### final

Защищает от изменений переменные, методы и классы.

**Переменная final**

Переменная, объявленная как `final`, после инициализации становится неизменной. Примитив изменить не выйдет, а для ссылочной переменной не удастся присвоить новую ссылку на другой объект (данные внутри объекта могут быть изменены).

Для `final` переменных на уровне класса значение устанавливается сразу или через конструктор.

Аргументы и локальные переменные метода также могут быть `final`. Тогда изменить их тоже не выйдет.
`final` локальную переменную метода можно объявить, но не инициализировать до момента ее использования. Такое поведение позволяет инициализировать `final` переменную по условию.

**Метод final**

Для методов `final` означает запрет на переопределение в наследниках.

**Класс final**

Для классов `final` означает запрет на дальнейшее наследование от такого класса.

---

##### static

С использованием модификатора `static` объявляются методы и переменные, которые не нуждаются в объекте класса. Таким образом, методы и переменные вызываются от класса, а не от объекта.

Нельзя применить к конструктору, а также к обычному классу, но к вложенному классу применить `static` можно.

Можно вызывать `static` методы и переменные от объекта, но делать так не рекомендуется:
Каждый объект обладает полями, которые содержат уникальные значения. Изменяя поле у одного объекта класса, мы не повлияем на поля другого объекта того же класса. Если изменить `static` поле, то оно изменится у всех экземпляров класса.

**Сокрытие**

Статический метод нельзя переопределить — `override` невозможен.

Если вы объявите одинаковый метод в классе-наследнике и в родительском классе, вы "скроете" метод родительского класса, но не переопределите. При обращении к такому методу всегда будет вызван метод исходя из типа ссылки, по которой идёт обращение к такому полю или методу.

Для создания статических методов и переменных используется "раннее связывание".

Static-метод не сможет вызывать обычные методы и поля класса, так как обычные методы и поля класса создаются только для объектов. Но вы можете из статик метода вызвать другой статик метод.

Бизнес-логика никогда не помещается в статик методы, а всякие утилитарные функции вполне могут быть статическими.
Если для работы статического метода приходится передавать много аргументов, спросите себя: "А должен ли он быть статическим?".

**Константы**

Модификатор `static` используется в связке с `final` для создания неизменяемых переменных. Таким образом, получается константное значение, которое доступно в любом месте программы.

**Утилитарные классы**

Статические методы из одной области работы группируются в отдельный класс. Такие классы называют `Utility`-классы. Их обычно помещают в пакет `utils`, тем самым намекая на то, что это класс для утилит.

В идеале такой класс ещё и `final`. Ни к чему таким классам участвовать в наследовании.

**Фабричный метод**

Статические методы используются также для создания экземпляров объектов, в зависимости от условий, для добавления промежуточной логики в создание объекта.

Конструктор не обладает уникальным именем. Когда много конструкторов у одного класса, сложно понять, какой за что отвечает. Используя фабричный метод, задавайте осмысленные имена и скрывайте вызов конструктора.

**Статический блок кода**

Инициализация статического блока кода выполняется на этапе загрузки класса. Используются, когда необходимо выполнить какую-то логику ещё до создания экземпляра объекта.

Если статических блоков в классе несколько, тогда их выполнение будет происходить в порядке объявления.

Статичный блок не может пробросить перехваченные исключения, но может выбросить не перехваченные. При возникновении исключения выбросится `ExceptionInInitializerError`.

**Статический вложенный класс**

Можно объявить класс внутри другого класса. Такой класс называется `nested`-классом. Вложенные классы делятся на статические и нестатические.

Статические вложенные классы называют внутренними классами (`inner`-классами).

`inner` классы принадлежат классу, в то время как `nested` классы принадлежат экземпляру класса.

---

##### abstract

Используется для создания абстрактных классов и методов. Абстрактность подразумевает некоторую незавершенность реализации класса/метода.

**Класс abstract**

Невозможно создать объект `abstract`-класса. Единственное предназначение такого класса — быть классом родителем.

Класс не может быть одновременно `abstract` и `final`, так как класс `final` позволяет создавать наследников.

Абстрактный класс может содержать обычные методы, а также static-методы.

**Метод abstract**

Абстрактный метод — это метод без реализации. Реализация такого метода должна быть описана в классе наследнике. По факту это переопределение метода. Это похоже на то, как работает интерфейс.

Методы `abstract` никогда не могут быть `final` или `static`.

Абстрактный класс может содержать как обычные методы, так и абстрактные. Обычный класс не может содержать абстрактные методы. Но абстрактный класс не обязан содержать абстрактные методы.

---

##### synchronized

Ключевое слово `synchronized` используется для указания того, что метод может быть доступен только одним потоком одновременно. `synchronized` может быть применён с любым из модификаторов уровня доступа.

---

##### volatile

Предназначен для многопоточной разработки. Доступ к переменной `volatile` синхронизирует все кэшированные переменные в оперативной памяти.

---

##### transient

Переменная экземпляра, отмеченная как `transient`, указывает JVM пропустить её при сериализации объекта.

Такой сериализацией в Java никто не пользуется. Поэтому считайте этот модификатор устаревшим.

---

[[!Теория для собеседования]]
[[!Java]]
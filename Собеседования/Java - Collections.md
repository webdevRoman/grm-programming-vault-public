---
tags:
  - interview
  - java
---
### Иерархия

![[java_collections_hierarchy.png|700]]

---

### HashMap

В основе - массив (bucket). Элементы бакета - структуры `LinkedList`, которые заполняются элементами, которые мы добавляем в `HashMap`.
Структуры `LinkedList` - класс `Node` (implements `Map.Entry`, находится в `HashMap`) с полями `final int hash`, `final K key`, `V value`, `Node<K, V> next`.

Добавление элемента в `HashMap` (`map.put(obj1, obj2)`):
1. Вычисляется хэш-код ключа
2. На основе хэш-кода ключа вычисляется индекс в бакете (`index = hashCode(key) & (n-1)`, где n - размер бакета)
3. Элемент добавляется в бакет:
	1. Если в бакете на этом индексе нет элемента, новый элемент добавляется в бакет
	2. Если на этом индексе элемент есть, и новый элемент не равен старому, новый элемент добавляется в `Node.next` элемента
	3. Если на этом индексе элемент есть, и новый элемент равен старому, новый элемент перетирает старый

Получение элемента из `HashMap` (`map.get(obj1)`):
1. Вычисляется хэш-код ключа
2. На основе хэш-кода ключа вычисляется индекс в бакете
3. Берётся элемент на этом индексе и сравнивается с `obj1`:
	1. Если равны, возвращается элемент
	2. Если не равны, и у элемента в бакете есть `Node.next`, `obj1` сравнивается с ним
	3. Если не равны, и у элемента в бакете нет `Node.next`, возвращается `null`

При проверках сначала сравниваются результаты `hashCode` ключей. Если они равны, сравниваются ещё результаты `equals` ключей.

При создании `HashMap` можно задать два параметра:
- `initialCapacity` - начальный размер бакета
- `loadFactor` - коэффициент того, насколько бакет должен быть заполнен, после чего его размер будет увеличен вдвое

Сложность вставки и получения значений из `HashMap`:
- O(1) - лучший случай, когда метод `hashCode` реализован хорошо и все элементы стоят на разных индексах в бакете
- O(n) - худший случай, когда все элементы стоят на одном индексе в бакете, - по сути просто `LinkedList`
- O(log n) - начиная с Java 8 - после достижения определённого количества элементов в `LinkedList`, он меняется на сбалансированное дерево

В ключах нужно использовать неизменяемые (immutable) объекты.

---

### HashSet

В `HashSet` используется `HashMap`.
При добавлении элемента он пишется в ключ `HashMap`, а значения у всех ключей в мапе - константа.
При создании можно указать те же параметры `initialCapacity` и `loadFactor`.

---

### ArrayList

Значения хранятся в массиве.

Добавление элемента в `ArrayList` (`list.add(obj)`):
1. Проверяется, достаточно ли места в массиве:
	1. Если места недостаточно, новая ёмкость рассчитывается по формуле `(oldCapacity * 3) / 2 + 1`, элементы из старого массива копируются в новый методом `System.arraycopy()`
2. Элемент добавляется в конец массива

Добавление элемента в середину `ArrayList` (`list.add(index, obj)`):
1. Проверяется, достаточно ли места в массиве
2. Подготавливается место для нового элемента - копируются все элементы, начиная с `index` на `index + 1` с помощью `System.arraycopy()`
3. Элемент с индексом `index` перезаписывается

Удаление элемента по индексу (`list.remove(index)`):
1. Определяется количество элементов для копирования: `int numMoved = size - index - 1;`
2. Элементы копируются: `System.arraycopy(elementData, index + 1, elementData, index, numMoved);`
3. Зануляется последний элемент: `elementData[--size] = null;`

Удаление элемента по значению (`list.remove(obj)`):
В цикле просматриваются все элементы списка до тех пор, пока не будет найдено соответствие. Далее - как при удалении по индексу.

При удалении элементов размер массива не уменьшается, что может привести к своеобразным утечкам памяти - не стоит пренебрегать методом `trimToSize()`.

- Быстрый доступ к элементам по индексу - O(1)
- Доступ к элементам по значению за линейное время - O(n)
- Медленный, когда вставляются и удаляются элементы из середины списка

---

### TODO

ArrayList больше подходит для работы с данными, LinkedList - для модификации данных
LinkedList, TreeMap, TreeSet

---

[[!Теория для собеседования]]
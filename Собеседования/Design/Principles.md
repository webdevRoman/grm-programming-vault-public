---
tags:
  - interview
  - principles
  - design
---
### Источники

https://habr.com/ru/articles/554474/
https://practicum.yandex.ru/blog/obektno-orientirovannoe-programmirovanie/
https://javarush.com/groups/posts/principy-oop
https://ru.wikipedia.org/wiki/SOLID_(программирование)
https://javarush.com/groups/posts/osnovnye-principy-dizajna-klassov-solid-v-java
https://habr.com/ru/companies/itelma/articles/546372/

---

### Парадигмы программирования

Парадигма программирования — набор правил и критериев, по которым пишут код. Парадигма помогает стандартизировать написание кода. Это снижает риск ошибок, ускоряет разработку и делает код более читабельным для других программистов.

Существует три основных парадигмы: структурное, объектно-ориентированное и функциональное.
Каждая из этих парадигм убирает возможности у программиста, а не добавляет. Они говорят нам скорее, что нам **не нужно делать**, чем то, что нам нужно делать.

**Cтруктурное программирование** (СП) позволяет делать функциональную декомпозицию.

Написание программ — подобно математическим доказательствам, которые также организованы в иерархии. Если в программах использовать только if, do, while, то такие программы можно легко рекурсивно разделять на более мелкие единицы, которые в свою очередь уже легко доказуемы.

СП отнимает возможность вставить goto где угодно.

**Объектно-ориентированное программирование** (ООП) — парадигма, методология или стиль программирования на основе описания типов/моделей предметной области и их взаимодействия, представленных порождением из прототипов или как экземпляры классов, которые образуют иерархию наследования.

ООП не позволяет получить доступ до скрытых членов классов и навязывает инверсию зависимостей.

**Функциональное программирование** (ФП). В основе функционального программирования — запрет на изменение переменных. Если переменная однажды проинициализирована, её значение так и остаётся неизменным.

Разделяем компоненты на изменяемые и неизменяемые. Как можно больше функциональности нужно положить именно в неизменяемые компоненты и как можно меньше в изменяемые. В изменяемых компонентах работаем с изменяемыми данными, которые можно защитить с помощью транзакционной памяти.

ФП запрещает изменять переменные.

---

### ООП

##### Структура

1. Объект
Часть кода, которая описывает элемент с конкретными характеристиками и функциями.

2. Класс
Шаблон, на базе которого можно построить объект.
Классы могут наследоваться друг от друга. Подкласс берёт свойства из родительского класса, при этом имеет свои свойства.

3. Метод
Функция внутри объекта или класса, которая позволяет взаимодействовать с ним или другой частью кода.

4. Атрибут
Характеристики объекта. В классе прописывают, что такие атрибуты есть, а в объектах с помощью методов заполняют эти атрибуты данными.

##### Принципы

1. Инкапсуляция
Атрибуты и поведение объекта объединяются в одном классе, внутренняя реализация объекта скрывается от пользователя, а для работы с объектом предоставляется открытый интерфейс.

2. Наследование
Использование уже существующих классов для описания новых.
Разработчик создаёт:
* Класс с определёнными свойствами
* Подкласс на его основе, который берёт свойства класса и добавляет свои
* Объект подкласса, который также копирует его свойства и добавляет свои
Каждый дочерний элемент наследует методы и атрибуты, прописанные в родительском. Он может использовать их все, отбросить часть или добавить новые. При этом заново прописывать эти атрибуты и методы не нужно.

3. Полиморфизм
Возможность использовать объекты с одинаковым интерфейсом без информации о внутреннем устройстве объекта.

Один интерфейс может использоваться для управления разными методами, давая разные результаты в зависимости от контекста.

Один и тот же метод может работать по-разному в зависимости от объекта, где он вызван, и данных, которые ему передали.

4. Абстракция
Способ представления элементов задачи из реального мира в виде объектов в программе. Выделение значимой информации и исключение из рассмотрения незначимой в контексте решаемой задачи. При этом уровней абстракции может быть несколько.

Предоставление основных функций без погружения в детали.

---

### SOLID

SOLID — 5 основных принципов объектно-ориентированных проектирования и программирования.

1. **Принцип единственной ответственности (single responsibility principle)**
У класса должна быть только одна причина для изменения.
Модуль должен отвечать за одного и только за одного актора.

На каждый объект возлагается одна обязанность, полностью инкапсулированная в класс. Все сервисы класса направлены на обеспечение этой обязанности.

2. **Принцип открытости/закрытости (open-closed principle)**
Программные сущности (классы, модули, функции и т.п.) должны быть открыты для расширения, но закрыты для модификации.

Должна быть возможность изменять внешнее поведение класса, не внося физические изменения в сам класс. Классы должны разрабатываться так, чтобы для подстройки класса к конкретным условиям применения было достаточно расширить его и переопределить некоторые функции.

3. **Принцип подстановки Лисков (Liskov substitution principle)**
Функции, которые используют базовый тип, должны иметь возможность использовать подтипы базового типа не зная об этом.

Объекты в программе можно заменить их наследниками без изменения свойств программы.
Класс, разработанный путем расширения на основании базового класса, должен переопределять его методы так, чтобы не нарушалась функциональность с точки зрения клиента. То есть, если разработчик расширяет ваш класс и использует его в приложении, он не должен изменять ожидаемое поведение переопределенных методов.
Подклассы должны переопределять методы базового класса так, чтобы не нарушалась функциональность с точки зрения клиента.

`List l = new ArrayList<Object>();`

4. **Принцип разделения интерфейса (interface segregation principle)**
Много интерфейсов, специально предназначенных для клиентов, лучше, чем один интерфейс общего назначения.

Слишком «толстые» интерфейсы необходимо разделять на более мелкие и специфические, чтобы клиенты мелких интерфейсов знали только о методах, необходимых в работе. В итоге, при изменении метода интерфейса не должны меняться клиенты, которые этот метод не используют. 

5. **Принцип инверсии зависимостей (dependency inversion principle)**
Зависимость на Абстракциях. Нет зависимости на что-то конкретное.

Модули верхнего уровня не зависят от модулей нижнего уровня. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.

---

### YAGNI

**You Aren’t Gonna Need It / Вам это не понадобится**

Если пишете код, то будьте уверены, что он вам понадобится. Не пишите код, если думаете, что он пригодится позже.

---

### DRY

**Don’t Repeat Yourself / Не повторяйтесь**

> В проектировании и теории информационных систем единый источник истины (SSOT) – это практика структурирования информационных моделей и схемы данных, которая подразумевает, что все фрагменты данных обрабатываются (или редактируются) только в одном месте… SSOT предоставляют достоверные, актуальные и пригодные к использованию данные.

Дублирование кода – пустая трата времени и ресурсов. Вам придется поддерживать одну и ту же логику и тестировать код сразу в двух местах, причем если вы измените код в одном месте, его нужно будет изменить и в другом.

В большинстве случаев дублирование кода происходит из-за незнания системы. Прежде чем что-либо писать, проявите прагматизм: осмотритесь. Возможно, эта функция где-то реализована. Возможно, эта бизнес-логика существует в другом месте. Повторное использование кода – всегда разумное решение.

---

### KISS

**Keep It Simple, Stupid / Будь проще**

Простые системы будут работать лучше и надежнее.

Не придумывайте к задаче более сложного решения, чем ей требуется.

Иногда самое разумное решение оказывается и самым простым. Написание производительного, эффективного и простого кода – это прекрасно.

---

### Big Design Up Front

**Глобальное проектирование прежде всего**

Прежде чем переходить к реализации, убедитесь, что все хорошо продумано.

Иногда в недостатках и процессах разработки архитектуры должны быть замешаны и другие люди. Чем раньше вы все это обсудите, тем лучше будет для всех.

---

### Avoid Premature Optimization

**Избегайте преждевременной оптимизации**

Не оптимизировать код до того, как необходимость этой оптимизации будет доказана.

Преждевременная оптимизация может привести к задержкам в коде и, следовательно, увеличит затраты времени на вывод функций на рынок.

---

### Бритва Оккама

«Не следует множить сущее без необходимости».

Не создавайте ненужных сущностей без необходимости. Будьте прагматичны — подумайте, нужны ли они, поскольку они могут в конечном итоге усложнить вашу кодовую базу.

---

[[!Теория для собеседования]]
[[!Design]]